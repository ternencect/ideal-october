# 动态规划

> 动态规划是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。

## 初探动态规划

示例： 爬楼梯：

给定一个共有 n 阶的楼梯，每步可以上 1 阶或者 2 阶，请问由多少种方案可以爬到楼顶。

### 解法1: 通过回溯来穷举所有可能性

```
/* 回溯 */
void backtrack(List<Integer> choices, int state, int n, List<Integer> res) {
    // 当爬到第 n 阶，方案数量加1
    if (state == n) {
        res.set(0, res.get(0) + 1);
    }
    // 遍历所有选择
    for (Integer choice : choices) {
        // 剪枝：不允许越过 n 阶
        if (state + choice > n) {
            break;
        }
        // 尝试：做出选择，更新状态
        backtrack(choices, state + choice, n, res);
        // 回退
    }
} 

/* 爬楼梯：回溯 */
int climbingStairsBacktrack(int n) {
    List<Integer> choices = Arrays.asList(1, 2); // 可选择向上爬 1 或 2 阶
    int state = 0;
    List<Integer> res = new ArrayList<>();
    res.add(0);
    backtrack(choices, state, n, res);
    return res.get(0);
}
```

### 解法2: 暴力搜索

爬到第 i - 1 阶的方案数加上爬到第 i - 2 阶的方案数就等于爬到第 i 阶的方案数。
dp[i] = dp[i-1] + dp[i-2]

这就意味着着爬楼梯问题中，各个子问题之间存在递推关系，**原问题的解可以由子问题的解构建得来**。

可以根据递推公式得到暴力搜索解法。以dp[n]为起始点，**递归地将一个较大问题拆解为两个较小问题的和**，直至到达最小子问题dp[1]和dp[2]时返回。
```
int dfs(int i) {
    // 已知dp[1]和dp[2]，返回之
    if (i == 1 || i == 2) {
        return i;
    }
    int count = dfs(i - 1) + dfs(i - 2);
    return count;
}

int climbingStairsDFS(int n) {
    return dfs(n);
}
```

暴力搜索形成的递归树，对于问题dp[n]，其递归树的深度为n，时间复杂度为O(2^n)。指数阶属于爆炸式增长。

**指数阶的时间复杂度是由于“重叠子问题”导致的。**

### 解法3: 记忆化搜索

为了提升算法效率，我们希望所有的重叠子问题都只被计算一次。为此，我们声明一个数组 mem 来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝。

1. 当首次计算dp[i]时，将其记录至 mem[i]，以便之后使用；
2. 当再次需要计算dp[i]时，便可直接从 mem[i] 中获取结果，从而避免重复计算子问题。

```
int dfs(int i, int[] mem) {
    if (i == 1 || i == 2) {
        return i;
    }
    // 若存在记录 dp[i]，则直接返回之
    if (mem[i] != -1)
        return mem[i];
    int count = dfs(i - 1, mem) + dfs(i - 2, mem);
    mem[i] = count;
    return count;
}

int climbingStairsDFSMem(int n) {
    int[] mem = new int[n + 1];
    Arrays.fill(mem, -1);
    return dfs(n, mem);
}
```

**经过记忆化处理后，所有重叠子问题都只需被计算一次，时间复杂度被优化至O(n)**

### 解法4: 动态规划

**记忆化搜索是一种“从顶至底”的方法**：从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。
之后通过回溯将子问题的解逐层收集，构建出原问题的解。

**动态规划是一种“从底至顶”的方法**：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。

由于动态规划不包含回溯过程，因此只需使用循环迭代实现，无须使用递归。

```
int climbingStairsDP(int n) {
    if (n == 1 || n == 2) {
        return n;
    }
    // 初始化 dp 表，用于存储子问题的解
    int[] dp = new int[n + 1];
    // 初始状态：预设最小子问题的解
    dp[1] = 1;
    dp[2] = 2;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```
初始状态：dp[1] = 1, dp[2] = 2

状态转移方程：dp[n] = dp[n - 1] + dp[n - 2]

**从初始状态开始，进行状态转移，到达目标状态时终止**

与回溯算法一样，动态规划也使用“状态”概念来表示问题求解的某个特定阶段，每个状态都对应一个子问题以及相应的局部最优解。

根据以上内容，可以总结出动态规划的常用术语。

- 将数组 `dp` 称为 「dp表」，dp[i] 表示状态 i 对应子问题的解
- 将最小子问题对应的状态称为「初始状态」
- 将递推公式 dp[i] = dp[i - 1] + dp[i - 2] 称为「状态转移方程」

### 空间优化

**由于dp[i]只与dp[i - 1]和dp[i - 2]有关，因此无须使用一个数组`dp`来存储所有子问题的解**，只需两个变量滚动前进即可。

```
int climbingStairsDPComp(int n) {
    if (n == 1 || n == 2)
        return n;
    int a = 1, b = 2;
    for (int i = 3; i < n; i++) {
        int temp = b;
        b = a + b;
        a = temp;   
    }
    return b;
}
```

由于省去了数组`dp`占用的空间，因此空间复杂度从O(n)降至O(1)。

在动态规划问题中，当前状态往往仅与前面有限个状态有关，可以只保留必要的状态，通过“降维”来节省内存空间。**这种空间优化技巧被称为“滚动变量”或“滚动数组”**。

## 动态规划问题特性

> 子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。
> - 分治算法递归地将原问题划成多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解。
> - 动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题。
> - 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，可以将每个决策步骤之前的子序列看作为一个子问题。
> 
> 实际上，动态规划常用来求解最优化问题，不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性。

### 最优子结构

示例： 爬楼梯最小代价：

给定一个楼梯，你每步可以上1阶或者2阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。
给定一个非负整数数组`cost`，其中 cost[i] 表示在第 i 个台阶需要付出的代价，cost[0] 为地面起始点。
请计算最少需要付出多少代价才能到达顶部？

设 dp[i] 为爬到第 i 阶累计付出的代价，由于第 i 阶只可能从 i - 1 阶或 i - 2 阶走来，因此 dp[i] 只可能等于 dp[i - 1] + cost[i] 或者
dp[i - 2] + cost[i]。为了尽可能减少代价，可以选择两者中较小的那一个：

dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]

**这便可以引出最优子结构的含义：原问题的最优解是从子问题的最优解构建得来的**。

爬楼梯的问题有没有最优子结构呢？它的目标是求解方案数量，看似是一个计数问题，但如果换另一个问法：“求解最大方案数量”。**虽然题目修改前后是等价的，但最优子结构浮现出来了**：
第 n 阶最大方案数量等于第 n - 1 阶和第 n - 2阶最大方案数量之和。

根据状态转移方程，以及初始状态 dp[1] = cost[1] 和 dp[2] = cost[2],可以得到动态规划代码。

```
int minCostClimbingStairsDP(int[] cost) {
    int n = cost.length - 1;
    if (n == 1 || n == 2) {
        return cost[n];
    }
    // 初始化 dp 表，用于存储子问题的解
    int[] dp = new int[n + 1];
    // 初始状态：预设最小子问题的解
    dp[1] = cost[1];
    dp[2] = cost[2];
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
    }
    return dp[n];
}
```
进行空间优化，将一维压缩至零维，使得空间复杂度从O(n) 降低至 O(1)。

```
int minCostClimingStairsDPComp(int[] cost) {
    int n = cost.length - 1;
    if (n == 1 || n == 2)
        return cost[n];
    int a = cost[1], b = cost[2];
    for (int i = 3; i <= n; i++) {
        int temp = b;
        b = Math.min(a, temp) + cost[i];
        a = temp;
    }
    return b;
}
```

### 无后效性

无后效性是动态规划能够有效解决问题的重要特性之一，定义为：**给定一个确定的状态，它的未来发展只与当前状态有关，而与当前状态过去所经历过的所有状态无关**。

示例： 带约束爬楼梯：

给定一个共有 n 阶的楼梯，每步可以上 1 阶或者 2 阶，**但不能连续两轮跳 1 阶**，请问有多少种方案可以爬到楼顶。

意味着，**下一步选择不能由当前状态独立决定，还和前一个状态有关**。

此问题已不满足无后效性，状态转移方程也失效了。为此，需要扩展状态定义：**状态[i, j]表示处在第 i 阶、并且上一轮跳了 j 阶，其中 j = 1/2。
此状态定义有效地区分了上一轮跳了1阶还是2阶，可以据此来决定下一步该怎么跳。
- 当 j 等于1，即上一轮跳了 1 阶时，这一轮只能选择跳 2 阶。
- 当 j 等于2，即上一轮跳了 2 阶时，这一轮可选择跳 1 阶或跳 2 阶。

在该定义下，dp[i, j]表示状态[i, j]对应的方案数。此时状态转移方程为：

- dp[i, 1] = dp[i - 1, 2]  
- dp[i, 2] = dp[i - 2, 1] + dp[i - 2, 2]

最终返回，dp[n, 1] + dp[n, 2]即可，两者之和代表爬到第 n 阶的方案总数。

```
int climbingStairsConstraintDP(int n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    // 初始化 dp 表，用于存储子问题的解
    int[][] dp = new int[n + 1][3];
    // 初始状态：预设最小子问题的解
    dp[1][1] = 1;
    dp[1][2] = 0;
    dp[2][1] = 0;
    dp[2][2] = 1;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i][1] = dp[i - 1][2];
        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];
    }
    return dp[n][1] + dp[n][2];
}
```

由于仅需多考虑前面一个状态，仍然可以通过扩展状态定义，使得问题重新满足无后效性。

## 动态规划解题思路

> 1. 如何判断一个问题是否是动态规划问题？
> 2. 求解动态规划问题应该从何处入手，完整步骤是什么？

### 问题判断

总的来说，如果一个问题包含重叠子问题、最优子结构，并满足无后效性，那么它通常就适合用动态规划求解。
然而，我们很难从问题描述上直接提取出这些特性。因此我们通常会放宽条件，**先观察问题是否适合使用回溯（穷举）解决**。

**适合用回溯解决的问题通常满足“决策树模型”**，这种问题可以使用树形结构来描述，其中每一个节点代表一个决策，每一条路径代表一个决策序列。

换句话说，如果问题包含明确的决策概念，并且解是通过一系列决策产生的，那么它就满足决策树模型，通常可以使用回溯来解决。

在此基础上，动态规划问题还有一些判断的“加分项”。

- 问题包含最大（小）或最多（少）等最优化描述。
- 问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系。

相应地，也存在一些“减分项”。

- 问题的目标是找出所有可能的解决方案，而不是找出最优解。
- 问题描述中有明显的排列组合的特征，需要返回具体的多个方案。

如果一个问题满足决策树模型，并具有较为明显的“加分项“，我们就可以假设它是一个动态规划问题，并在求解过程中验证它。

### 问题求解步骤

动态规划的解题流程会因问题的性质和难度而有所不同，但通常遵循以下步骤：描述决策，定义状态，建立`dp`表，推导状态转移方程，确定边界条件等。

示例：最小路径和

给定一个 n * m 的二维网格 `gird`，网格中的每个单元格包含一个非负证书，表示该单元格的代价。
机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和。

**第一步：思考每轮的决策，定义状态，从而得到 `dp` 表**

动态规划和回溯过程可以被描述为一个决策序列，而状态由所有决策变量构成。它应当包含描述解题进度的所有变量，其包含了足够的信息，能够用来推导出下一个状态。

每个状态都对应一个子问题，定义一个 dp 表来存储所有子问题的解，状态的每个独立变量都是 dp 表的一个维度。**本质上看，dp表是状态和子问题的解之间的映射**。

**第二步：找出最优子结构，进而推导出状态转移方程**

**根据定义好的 dp 表，思考原问题和子问题的关系，找出通过子问题的最优解来构造原问题的最优解的方法，即最优子结构**。

一旦找到最优子结构，就可以使用它来构建出状态转移方程。

**第三步：确定边界条件和状态转移顺序**

边界条件在动态规划中用于初始化 dp 表，在搜索中用于剪枝。

状态转移顺序的核心是要保证在计算当前问题的解时，所有它依赖的更小子问题的解都已经被正确地计算出来。

## 0-1背包问题

> 给定 n 个物品，第 i 个物品的重量为 wgt[i-1]、价值为 val[i-1]，和一个容量为 cap 的背包。每个物品只能选择一次。
> 问在不超过背包容量下，能放入物品的最大价值。

将0-1背包问题看作是一个由n轮决策组成的过程，每个物体都有不放入和放入两种决策，因此该问题是满足决策树模型的。

该问题的目标是求解“在限定背包容量下的最大价值”，因此较大概率是个动态规划问题。

**第一步：思考每轮的决策，定义状态，从而得到`dp`表**

对于每个物品来说，不放入背包：背包容量不变；放入背包，背包容量减少。由此可得状态定义：当前物品编号i和剩余背包容量c，记为[i, c]。

状态[i, c]对应的子问题为：**前i个物品在剩余容量为c的背包中的最大价值**，记为`dp[i, c]`。

待求解的是 dp[n, cap]，因此需要一个尺寸为(n + 1) * (cap + 1)的二维 dp 表。

**第二步：找出最优子结构，进而推导出状态转移方程**

当做出物品i的决策后，剩余的是前i-1个物品的决策，可分为两种情况。

- **不放入物品i**：背包容量不变，状态变化为[i-1, c]。
- **放入物品i**：背包容量减少wgt[i - 1]，价值增加val[i - 1]，状态变化为[i - 1, c - wgt[i - 1]]。

本题的最优子结构：**最大价值dp[i,c]等于不放入物品i和放入物品i两种方案中的价值更大的那一个**。由此推出状态转移方程：

dp[i, c] = max(dp[i - 1, c], dp[i - 1, c - wgt[i - 1]] + val[i - 1])

需要注意的是，若当前物品重量 wgt[i - 1]超出剩余背包容量 c，则只能选择不放入背包。

**第三步：确定边界条件和状态转移顺序**

当无物品或无剩余背包容量时最大价值为0，即首列dp[i, 0]和首行dp[0, c]都等于0。

当前状态[i, c]从上方的状态[i - 1, c]和左上方的状态[i - 1, c - wgt[i - 1]]转移而来，因此通过两层循环正序遍历整个dp表即可。

### 方法一：暴力搜索

搜索代码包含以下要素

- **递归参数**：状态[i, c]
- **返回值**：子问题的解dp[i, c]
- **终止条件**：当物品编号越界i == 0 或背包剩余容量为 0 时，终止递归并返回价值 0。
- **剪枝**：若当前物品重量超出背包剩余容量，则只能不放入背包。

```
int knapsackDFS(int[] wgt, int[] val, int i, int c) {
    // 若已选完所有物品或背包无容量，则返回价值0
    if （i == 0 || c == 0) {
        return 0;
    }
    // 若超过背包容量，则只能不放入背包
    if (wgt[i - 1] > c) {
        return knapsackDFS(wgt, val, i - 1, c);
    }
    // 计算不放入和放入物品 i 的最大价值
    int no = knapsackDFS(wgt, val, i - 1, c);
    int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];
    // 返回两种方案中价值更大的那一个
    return Math.max(no, yes);
}
```

### 方法二：记忆化搜索

为了保证重叠子问题只被计算一次，借助记忆列表 mem 来记录子问题的解，其中 mem[i][c] 对应 dp[i, c]。

引入记忆化之后，**时间复杂度取决于子问题数量**，也就是O(n * cap)。

```
int knapsackDFSMem(int[] wgt, int[] val, int[][] mem, int i, int c) {
    // 若已选完所有物品或背包无容量，则返回价值 0
    if (i == 0 || c == 0) {
        return 0;
    }
    // 若已有记录，则直接返回
    if (mem[i][c] != -1) {
        return mem[i][c];
    }
    // 若超过背包容量，则只能不放入背包
    if (wgt[i - 1] > c) {
        return knapsackDFSMem(wgt, val, mem, i - 1, c);
    }
    // 计算不放入和放入物品 i 的最大价值
    int no = knapsackDFSMem(wgt, val, mem, i - 1, c);
    int yes = knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];
    // 记录并返回两种方案中价值更大的那一个
    mem[i][c] = Math.max(no, yes);
    return mem[i][c];
}
```

### 方法三：动态规划

动态规划实质上就是在状态转移中填充dp表的过程

```
int knapsackDP(int[] wgt, int[] val, int cap) {
    int n = wgt.length;
    // 初始化 dp 表
    int[][] dp = new int[n + 1][cap + 1];
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int c = 1; c <= cap; c++) {
            if (wgt[i - 1] > c) {
                // 若超过背包容量，则不选物品 i
                dp[i][c] = dp[i - 1][c];
            } else {
                // 不选和选物品 i 这两种方案的较大值
                dp[i][c] = Math.max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);
            }
        }
    }
    return dp[n][cap];
}
```